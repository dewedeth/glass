import { Guides } from '@/components/Guides'
import { Resources } from '@/components/Resources'
import { HeroPattern } from '@/components/HeroPattern'

export const description =
  'Glass is a domain-specific language for prompting LLMs.'

export const sections = []

# Advanced example

Here's a long `.glass` file that demonstrates many of the advanced features of Glass, including imports, async code blocks, and comments:

![Example of an advanced prompt](/Users/shreyasparab/Developer/language.glass/src/images/exampleImages/AdvancedExample.jpeg)

````mdx
---
query: string What the user typed
namespace: string Embeddings namespace to query
---

Welcome to Glass! With Glass you'll have a much better time writing LLM prompts.

The first great thing about Glass is that you don't have to escape characters so much!

Use `ticks`, or "double quotes", or 'single quotes', or even "double quotes with 'single quotes' inside".

Did you notice:

- you haven't had to escape anything yet
- you can use tabs and newlines easily
- you have syntax highlighting!

That's right, syntax highlighting is built into Glass. You can even use it to help you write code blocks.

```js
async function foo() {
  const res = await fetch('https://api.foundation-ui.com/app/ping')
  return await res.text()
}
```

Can you imagine how much harder it would be to write that correctly without syntax highlighting?

Why would you want to write code blocks in your prompt?

Whenever you want the LLM to do anything with code:

- summarize it
- fix it
- generate it

Ok, but what about when I need to do more complicated things? I need to run business logic to generate the prompt.

In Glass, you can write code blocks that will be interpolated into your prompt. For example:

{"hello world"}

Evaluates the expression `"hello world"` in JavaScript and will then insert it into the prompt. I repeat:

{'You can write JavaScript code in Glass!!!!'.repeat(4)}

Did you notice that if you make a syntax error the Glass compiler will tell you about it? Try breaking the code above.
You may have also noticed that you can hover over code for tooltips, jump to definition, etc.

You can even run longer async code blocks:

{
async function foo() {
const res = await fetch('https://api.foundation-ui.com/app/ping')
return await res.text()
}
}

Man, this prompt is getting pretty long right? Even if it isn't long, sometimes I really want to leave a note about why I wrote
the prompt a certain way. For this, you can use comments. They won't be interpolated into your prompt, but they'll make it
a lot easier to understand what you're doing.

{/* yay comments!!! */}

But you don't have to write all your code in one Glass file. That would be terrible. A lot of your code is already written
somewhere else. You can import it into your Glass file.

import { fetchEmbeddings } from '../util/fetchEmbeddings.js'

{fetchEmbeddings(query, namespace)}

You can even import other Glass files to help you decompose your large prompts, or to share snippets between prompts.
````

<Resources />
